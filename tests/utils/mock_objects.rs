//! Mock objects for testing external dependencies.\n\nuse OxideAgent::core::llm::ollama::{ChatResponse, ChatMessage as OllamaChatMessage};\nuse OxideAgent::types::{ChatMessage, Tool, ToolCall, ToolFunction};\nuse reqwest::Client;\nuse serde_json::Value;\nuse std::collections::HashMap;\nuse std::sync::{Arc, Mutex};\nuse tokio::sync::mpsc;\n\n/// Mock Ollama API client for testing\npub struct MockOllamaClient {\n    responses: HashMap<String, ChatResponse>,\n    default_response: Option<ChatResponse>,\n}\n\nimpl MockOllamaClient {\n    pub fn new() -> Self {\n        Self {\n            responses: HashMap::new(),\n            default_response: None,\n        }\n    }\n\n    pub fn with_response(mut self, model: &str, response: ChatResponse) -> Self {\n        self.responses.insert(model.to_string(), response);\n        self\n    }\n\n    pub fn with_default_response(mut self, response: ChatResponse) -> Self {\n        self.default_response = Some(response);\n        self\n    }\n\n    pub async fn send_chat(\n        &self,\n        _client: &Client,\n        model: &str,\n        _messages: &[ChatMessage],\n        _tools: &[Tool],\n        _stream: bool,\n        _tx: mpsc::Sender<OxideAgent::types::AppEvent>,\n    ) -> anyhow::Result<Option<ChatMessage>> {\n        // Return a predefined response based on the model, or default if none exists\n        let response = if let Some(response) = self.responses.get(model) {\n            response.clone()\n        } else if let Some(default) = &self.default_response {\n            default.clone()\n        } else {\n            // Return a default empty response\n            ChatResponse {\n                model: model.to_string(),\n                created_at: chrono::Utc::now().to_rfc3339(),\n                message: OllamaChatMessage {\n                    role: \"assistant\".to_string(),\n                    content: \"Mock response\".to_string(),\n                    images: vec![],\n                },\n                done: true,\n                total_duration: 0,\n                load_duration: 0,\n                prompt_eval_count: 0,\n                prompt_eval_duration: 0,\n                eval_count: 0,\n                eval_duration: 0,\n            }\n        };\n\n        // Convert the Ollama response to the application's ChatMessage\n        Ok(Some(OxideAgent::types::ChatMessage {\n            role: response.message.role,\n            content: response.message.content,\n            tool_calls: None, // Simplified for testing\n        }))\n    }\n}\n\n/// Mock file system operations for testing\n#[derive(Clone)]\npub struct MockFileSystem {\n    files: Arc<Mutex<HashMap<String, String>>>,\n}\n\nimpl MockFileSystem {\n    pub fn new() -> Self {\n        Self {\n            files: Arc::new(Mutex::new(HashMap::new())),\n        }\n    }\n\n    pub fn with_file(mut self, path: &str, content: &str) -> Self {\n        let mut files = self.files.lock().unwrap();\n        files.insert(path.to_string(), content.to_string());\n        self\n    }\n\n    pub fn read_file(&self, path: &str) -> anyhow::Result<String> {\n        let files = self.files.lock().unwrap();\n        match files.get(path) {\n            Some(content) => Ok(content.clone()),\n            None => Err(anyhow::anyhow!(\"File not found: {}\", path)),\n        }\n    }\n\n    pub fn write_file(&mut self, path: &str, content: &str) -> anyhow::Result<()> {\n        let mut files = self.files.lock().unwrap();\n        files.insert(path.to_string(), content.to_string());\n        Ok(())\n    }\n\n    pub fn file_exists(&self, path: &str) -> bool {\n        let files = self.files.lock().unwrap();\n        files.contains_key(path)\n    }\n    \n    pub fn remove_file(&self, path: &str) -> anyhow::Result<()> {\n        let mut files = self.files.lock().unwrap();\n        files.remove(path);\n        Ok(())\n    }\n    \n    pub fn clear(&self) {\n        let mut files = self.files.lock().unwrap();\n        files.clear();\n    }\n}\n\n/// Mock shell command executor for testing\npub struct MockShellExecutor;\n\nimpl MockShellExecutor {\n    pub fn new() -> Self {\n        Self\n    }\n\n    pub fn execute_command(&self, command: &str) -> anyhow::Result<String> {\n        // For testing purposes, we'll simulate some common commands\n        match command {\n            \"echo 'Hello, World!'\" => Ok(\"Hello, World!\\n\".to_string()),\n            \"ls\" => Ok(\"file1.txt\\nfile2.txt\\n\".to_string()),\n            \"pwd\" => Ok(\"/mock/path\\n\".to_string()),\n            cmd if cmd.starts_with(\"echo \") => {\n                // Extract the text after echo for simple cases\n                let text = cmd.trim_start_matches(\"echo \").trim_matches('\\'');\n                Ok(format!(\"{}\\n\", text))\n            }\n            _ => Ok(format!(\"Mock output for: {}\\n\", command)),\n        }\n    }\n}\n\n/// Mock tool for testing tool functionality\npub struct MockTool {\n    name: String,\n    description: String,\n    parameters: Value,\n    should_fail: bool,\n    result: String,\n}\n\nimpl MockTool {\n    pub fn new(\n        name: &str,\n        description: &str,\n        parameters: Value,\n        should_fail: bool,\n        result: &str,\n    ) -> Self {\n        Self {\n            name: name.to_string(),\n            description: description.to_string(),\n            parameters,\n            should_fail,\n            result: result.to_string(),\n        }\n    }\n\n    pub fn execute(&self, _args: &Value) -> anyhow::Result<String> {\n        if self.should_fail {\n            Err(anyhow::anyhow!(\"Mock tool failed as requested\"))\n        } else {\n            Ok(self.result.clone())\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n\n    #[test]\n    fn test_mock_file_system() {\n        let mut fs = MockFileSystem::new();\n        fs.write_file(\"test.txt\", \"Hello, World!\").unwrap();\n\n        assert!(fs.file_exists(\"test.txt\"));\n        assert_eq!(fs.read_file(\"test.txt\").unwrap(), \"Hello, World!\");\n\n        // Test non-existent file\n        assert!(fs.read_file(\"nonexistent.txt\").is_err());\n    }\n\n    #[test]\n    fn test_mock_shell_executor() {\n        let executor = MockShellExecutor::new();\n        \n        let result = executor.execute_command(\"echo 'Hello, World!\"\\n\");\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), \"Hello, World!\\n\");\n    }\n\n    #[test]\n    fn test_mock_tool_success() {\n        let tool = MockTool::new(\n            \"test_tool\",\n            \"A test tool\",\n            json!({}),\n            false, // should not fail\n            \"Success result\",\n        );\n\n        let result = tool.execute(&json!({}));\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), \"Success result\");\n    }\n\n    #[test]\n    fn test_mock_tool_failure() {\n        let tool = MockTool::new(\n            \"failing_tool\",\n            \"A failing test tool\",\n            json!({}),\n            true, // should fail\n            \"This shouldn't be returned\",\n        );\n\n        let result = tool.execute(&json!({}));\n        assert!(result.is_err());\n    }\n}\n